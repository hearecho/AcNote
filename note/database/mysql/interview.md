### 1.mysql索引失效的情况

1. 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)
2. 对于多列索引，不是使用的第一部分(第一个)，则不会使用索引（最左匹配）
3. like查询是以%开头
4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
5. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引

### 2.Mysql怎么解决脏读，怎么解决幻读

1. 脏读将隔离级别设置为提交读，就可以解决脏读了
2. 使用 MVCC + Next-Key Locks 可以解决幻读问题

### 3.mysql发生死锁的情况

一个sql语句在修改一条记录的时间，会加上排他锁，多个事务同时执行两条互相相反的修改语句，便会造成死锁；

### 4.mysql分区分表

1. 分表:垂直分表（分列）和水平分表（将历史数据）
2. 分区

### 5.mysql主从复制

https://segmentfault.com/a/1190000008942618

> 在MySQL主从复制架构中，读操作可以在所有的服务器上面进行，而写操作只能在主服务器上面进行。主从复制架构虽然给读操作提供了扩展，可如果写操作也比较多的话（多台从服务器还要从主服务器上面同步数据），单主模型的复制中主服务器势必会成为性能瓶颈。

1. 基于记录的复制：主服务器上面执行的语句在从服务器上面再执行一遍，在MySQL-3.23版本以后支持。

   存在的问题：时间上可能不完全同步造成偏差，执行语句的用户也可能是不同一个用户

2. 基于语句的复制：把主服务器上面改编后的内容直接复制过去，而不关心到底改变该内容是由哪条语句引发的，在MySQL-5.0版本以后引入。

   存在的问题：比如一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于行的复制则要复制一万行的内容，由此造成的开销比较大，而基于语句的复制仅仅一条语句就可以了。
   

#### 复制过程
1. 在每个事务更新数据完成之前，master在二进制日志记录这些改变。写入二进制日志完成后，master通知存储引擎提交事务。
2.Slave将master的binary log复制到其中继日志。首先slave开始一个工作线程（I/O），I/O线程在master上打开一个普通的连接，然后开始binlog dump process。binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件，I/O线程将这些事件写入中继日志。
3.Sql slave thread（sql从线程）处理该过程的最后一步，sql线程从中继日志读取事件，并重放其中的事件而更新slave数据，使其与master中的数据一致，只要该线程与I/O线程保持一致，中继日志通常会位于os缓存中，所以中继日志的开销很小。

### 6.mysql索引

### 创建索引的方式

1. create unique index indexName on table(username(length))
2. alter table mytable add unique [indexname] (username(length))
3. 创建表的时间指定

####  为什么主键用auto_increment

> 关键不在于自动，而是在于增加，由于mysql使用的b+树作为索引，查询，所有的叶节点之间有指针相连接，使用按照一定顺序的增加的索引能够很快的判断数据的位置；

https://xlzd.me/2018/09/14/why-mysql-innodb-need-auto-increment-primary-key/

#### 如何生成UUID，以及UUID的缺点

```java
UUID uuid = UUID.randomUUID();
System.out.println(uuid);
String dxmbid = uuid.toString().replace("-", "");		System.out.println(dxmbid);
System.out.println(dxmbid.length());
```

缺点:

1. 占空间太大
2. 索引效率低
3. UUID是唯一随机的，不适合人读
4. 无法排序

#### 查询主键/非主键索引的实现方式

基于非主键索引的查询**需要多扫描一棵索引树,因此，我们在应用中应该尽量使用主键查询**。

#### 回表查询和覆盖索引

https://www.cnblogs.com/myseries/p/11265849.html

#### 联合索引B+树上的机构，-最左匹配

https://blog.csdn.net/weixin_30531261/article/details/79329722

### 7. mysql锁

#### 排他锁-X锁-写锁

使用时间一点要获取IX锁，且不能再加其他锁

#### 共享锁-S锁-读锁

使用时间一点要获取IS锁或者IX锁，可以和其他S锁共享；

#### 意向锁

> 不是真正的锁

##### IX锁

##### IS锁

#### record locks

> 锁定一个记录上的索引，而不是记录本身。
>
> 如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用

#### gap locks

> 锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

#### Next-Key Locks

它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```sql
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```

#### 乐观锁和悲观锁

##### 乐观锁

> 每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。

实现方式:

1. 使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。
2. 使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。

> 每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。

### mysql事务的性质

#### 原子性

> 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
>
> 回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可

#### 一致性

> 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。

#### 隔离性

> 一个事务所做的修改在最终提交以前，对其它事务是不可见的。

#### 事务性

> 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
>
> 使用重做日志来保证持久性。

### 数据库调优

https://www.jianshu.com/p/55020afb5eba

#### 数据库优化四个维度

> 数据库优化**维度**有四个:
> **硬件**、**系统配置**、**数据库表结构**、**SQL及索引**
> 优化**成本**:
> **硬件**>**系统配置**>**数据库表结构**>**SQL及索引**
> 优化**效果**:
> **硬件**<**系统配置**<**数据库表结构**<**SQL及索引**

#### msyql慢查询分析

```sql
show variables like 'slow%'; 
+---------------------+----------------------------------------------------------+
| Variable_name       | Value                                                    |
+---------------------+----------------------------------------------------------+
| slow_launch_time    | 2                                                        |
| slow_query_log      | OFF                                                      |
| slow_query_log_file | D:\code_envir\mysql-8.0.19-winx64\Data\hearecho-slow.log |
+---------------------+----------------------------------------------------------+
slow_launch_time  查询时间阈值不超过2s
slow_query_log：查询记录是否打开
slow_query_log_file：查询记录位置
```

#### 分库分表

### 事务隔离级别，4个隔离级别分别有什么并发问题？

| 隔离级别   | 解决问题                                                     | 锁的级别                 |
| ---------- | ------------------------------------------------------------ | ------------------------ |
| 未提交读RU | 解决了更新丢失问题，却会出现脏读                             |                          |
| 提交读RC   | 别避免了脏读，但是却可能出现不可重复读                       | 读取不加锁，更删改加行锁 |
| 可重复读RR | 避免了不可重复读取和脏读，但是有时可能出现幻读               |                          |
| 可序列化   | 在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。 |                          |

### sql优化

1. 应尽量避免在**where** 子句中对字段进行null 值判断

```sql
select id from t where num is null
建议将null设置为0
```

2. 应尽量避免在**where** 子句中使用!=或<>操作符
3. 应尽量避免在**where** 子句中使用**or** 来连接条件
4. **in** 和**not** **in** 也要慎用能用**between**就用**between**
5. 通配符最好不要放在第一位

```sql
select id from t where name like '%abc%'
不建议
```

6. 如果在**where** 子句中使用参数，也会导致全表扫描。因为**SQL**只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推 迟到运行时；它必须在编译时进行选择。
7. 应尽量避免在**where** 子句中对字段进行表达式操作
8. 应尽量避免在**where**子句中对字段进行函数操作
9. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。
10. 很多时候用**exists** 代替**in** 是一个好的选择

```sql
select num from a where exists(select 1 from b where num=a.num)
```

### Explain各个字段的含义

> explain + select语句

| 字段名        | 含义                                                         |
| ------------- | ------------------------------------------------------------ |
| id            | SELECT识别符。这是SELECT查询序列号。这个不重要,查询序号即为sql语句执行的顺序 |
| select_type   | select的类型: simple：简单select语句、primay：最外面的select,在有子查询的语句中，最外面的select查询就是primary,上图中就是这样、union：union union语句的第二个或者说是后面那一个.现执行一条语句、dependent union：UNION中的第二个或后面的SELECT语句，取决于外面的查询、union result：union的结果 |
| table         | 输出的行所用的表                                             |
| type          | system、const、eq_ref、ref。。。。                           |
| possible_keys | 提示使用哪个索引会在该表中找到行                             |
| keys          | MYSQL使用的索引，                                            |
| key_len       | MYSQL使用的索引长度                                          |
| ref           | ref列显示使用哪个列或常数与key一起从表中选择行               |
| rows          | 显示MYSQL执行查询的行数,数值越大越不好，说明没有用好索引     |
| extra         | 该列包含MySQL解决查询的详细信息。                            |

### mysql主从复制

https://segmentfault.com/a/1190000008942618

1. sql语句复制
2. 记录复制
3. 混合复制

### 主从复制或读写分离等数据不一致性问题以及如何解决

https://blog.csdn.net/weixin_43885417/article/details/101676610

1. 同步复制
2. 利用中间件，进行分发，将复制期间的读路由路由到主数据库；
3. 利用缓存，缓存过期时间为复制时间






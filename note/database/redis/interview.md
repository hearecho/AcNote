### redis内存淘汰策略

可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。

Redis 具体有 6 种淘汰策略：

| 策略            | 描述                                                 |
| --------------- | ---------------------------------------------------- |
| volatile-lru    | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
| volatile-ttl    | 从已设置过期时间的数据集中挑选将要过期的数据淘汰     |
| volatile-random | 从已设置过期时间的数据集中任意选择数据淘汰           |
| allkeys-lru     | 从所有数据集中挑选最近最少使用的数据淘汰             |
| allkeys-random  | 从所有数据集中任意选择数据进行淘汰                   |
| noeviction      | 禁止驱逐数据                                         |

作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。

使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。

Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。

### 什么是Redis缓存雪崩？什么是Redis缓存穿透？

1. redis缓存穿透：很多请求不存在的key直接落在数据库上，缓存失去意义

解决方法：

1、缓存层缓存空值。 
–缓存太多空值，占用更多空间。（优化：给个空值过期时间） 
–存储层更新代码了，缓存层还是空值。（优化：后台设置时主动删除空值，并缓存把值进去）

2、将数据库中所有的查询条件，放到布隆过滤器中。当一个查询请求来临的时候，先经过布隆过滤器进行检查，如果请求存在这个条件中，那么继续执行，如果不在，直接丢弃

2. redis缓存雪崩：很多key同时失效，导致产生大量的缓存穿透，

解决方法：
1. 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
2. 可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存
3. 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀
4. 做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。

### Redis主从模式、哨兵模式和集群模式区别

#### 主从模式

> 为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。为此， Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。

```c
//主不用配置，从redis的conf文件加入 slaveof ip port 就可以了
```

##### 复制原理

> 当从数据库启动时，会向主数据库发送sync命令，主数据库接收到sync后开始在后台报错快照rdb，在保存快照期间受到的命名缓存起来，当快照完成时，主数据库会将快照和缓存的命令一块发送给从。复制初始化结束。
> 之后，主每受到1个命令就同步发送给从。
> 当出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库。增量复制，使用的是psync命令

#### 哨兵模式

> 哨兵的作用就是监控redis主、从数据库是否正常运行，主出现故障自动将从数据库转换为主数据库。
>
> 顾名思义，哨兵的作用就是监控Redis系统的运行状况。它的功能包括以下两个。
>
> （1）监控主数据库和从数据库是否正常运行。
> （2）主数据库出现故障时自动将从数据库转换为主数据库。

#### 集群模式

> 即使使用哨兵，redis每个实例也是全量存储，每个redis存储的内容都是完整的数据，浪费内存且有木桶效应。为了最大化利用内存，可以采用集群，就是分布式存储。即每台redis存储不同的内容，

### redis IO模型

### redis事务

> 单个命令是原子性，但是事务不是原子性的

https://www.runoob.com/redis/redis-transactions.html

它先以 **MULTI** 开始一个事务， 然后将多个命令入队到事务中， 最后由 **EXEC** 命令触发事务

### 自己设计一个本地缓存

1. 使用ConcurrentHashMap存储缓存
2. 使用一个List存储最近最久未使用的缓存对象的key
3. 存储对象设置一个字段ttl，一个字段存储插入时间，便于后期删除过期时间；

https://blog.csdn.net/qq_35030994/article/details/80871279

### redis持久化

https://juejin.im/post/5b70dfcf518825610f1f5c16#heading-7

#### rdb持久化

1. 手动触发时间使用save会阻塞redis服务器，bgsave不会

#### aof持久化

### 如何保证缓存和数据库的数据一致性？

1. 先更新缓存，再更新数据库

> 更新数据库失败，导致数据库是老数据，因为需要持久化，所以最好先更新数据库；

1. 先更新数据库，再更新缓存

> 容易造成并发问题，不可选；当连着两个线程均要更新数据时间，数据库和缓存中的数据是两个不同的值

1. 先删除缓存，再更新数据库

> 一个读取线程，一个写线程，读取线程或许会把旧值重新写回缓存；

1. 先更新数据库，再删除缓存

> 最常用的方案

### redis是单线程为啥那么快

> 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
>
> 2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
>
> 3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
>
> 4、使用多路I/O复用模型，非阻塞IO；
>
> 5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

### 五种IO模型的区别

1. BIO，同步阻塞IO，阻塞整个步骤，如果连接少，他的延迟是最低的，因为一个线程只处理一个连接，适用于少连接且延迟低的场景，比如说数据库连接。
2. NIO，同步非阻塞IO，阻塞业务处理但不阻塞数据接收，适用于高并发且处理简单的场景，比如聊天软件。
3. 多路复用IO，他的两个步骤处理是分开的，也就是说，一个连接可能他的数据接收是线程a完成的，数据处理是线程b完成的，他比BIO能处理更多请求。
4. 信号驱动IO，这种IO模型主要用在嵌入式开发，不参与讨论。
5. 异步IO，他的数据请求和数据处理都是异步的，数据请求一次返回一次，适用于长连接的业务场景。
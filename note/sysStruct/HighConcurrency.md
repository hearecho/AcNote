# 1.高并发情况下的解决策略

> 总体上说，使用缓存，异步，和分布式是解决峰值相应，高并发的三种基本策略；

#### 1.1 互联网层

1. 使用负载均衡，例如使用nginx服务器；
2. 使用内容分发网络cdn，尽快的使用户获取所需内容

#### 1.2 web服务器层

1. 将会话的管理，放入到cookie中进行管理，但是如果浏览器禁用cookie会无法使用，所以一般在分布式过程中，可以专门设置一个存储所有session的位置；解决session同步问题
2. 将动态页面静态化，这种方式经常用于不经常更新数据的页面，剩余会动态变化的数据可以使用ajax进行更新；
3. 使用缓存，主要是浏览器端缓存js/css文件，或者是cdn技术做大量页面缓存，同时也可以使用自己搭建的缓存服务器存储访问频率较高的页面；
4. Gzip:利用浏览器能自行进行gzip解压缩的原理对静态资源进行压缩，减少资源大小；
5. 将图片，或者css，js文件等合成一个大资源；例如，图标之类的，可以将很多小图片放到一张大图片上；
6. Websphere Cluster。集群

#### 1.3 应用服务器或者业务服务器层

1. 使用分布式系统，微服务等
2. 使用Cache，这一层的缓存主要是对高频数据进行缓存，比如对中间计算结果进行缓存，而且是基于内存缓存居多，比如Memcached和Redis，
3. 同步转异步，使用消息队列：rabbitMQ

#### 1.4 数据访问、文件访问、内部网络访问层

1. 读写分离，高并发情况下一般写的的机会很少，大多都是读取数据；让主数据库（master）处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库（slave）处理SELECT查询操作

2. DB Cluster：数据库集群是利用至少两台或者多台数据库服务器，构成一个虚拟单一数据库逻辑映像，像单数据库系统那样，向客户端提供透明的数据服务。
3. 分布式存储**DAS/NAS/SAN**
4. Cache ：对要求不是特别实时的大数据进行预统计分析，然后缓存下来做报表等，这个时候直接从缓存里读取即可，提高统计速度。
5. 使用非关系型数据库redis
6. 分库分表分区

# 实例：秒杀系统的设计

> 秒杀的特点就是这样**时间极短**、 **瞬间用户量大**。

### 1.主要问题

1. 高并发问题
2. 超卖问题
3. 恶意请求问题的解决
4. 链接暴露
5. 数据库问题

### 2.解决方法

#### 2.1 服务单一原则

> 将一个秒杀系统使用微服务架构，集成在原来的订单服务，登陆服务中；单独给他建立一个数据库，现在的互联网架构部署都是**分库**的，一样的就是订单服务对应订单库，秒杀我们也给他建立自己的秒杀库。
>
> 主要是防止秒杀系统挂了导致整个系统不可用；

### 2.2秒杀链接加盐

> 主要是为了防止链接暴露的问题，将URL动态化，而且还能防止利用暴露的链接进行恶意的请求；前端传入的URL要进行检验；

#### 2.3Redis集群

> **Redis集群**，**主从同步**、**读写分离**，我们还搞点**哨兵**，开启**持久化**直接无敌高可用！

#### 2.4Nginx

> 是**高性能的web服务器**，并发也随便顶几万不是梦，但是我们的**Tomcat**只能顶几百的并发呀，那简单呀**负载均衡**嘛

#### 2.5资源静态化

> 秒杀一般都是特定的商品还有页面模板，现在一般都是前后端分离的，所以页面一般都是不会经过后端的，但是前端也要自己的服务器啊，那就把能提前放入**cdn服务器**的东西都放进去，反正把所有能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力。

#### 2.6按钮控制

> 防止用户一直点击请求按钮，导致处理请求过多

#### 2.7限流

> **前端限流**：这个很简单，一般秒杀不会让你一直点的，一般都是点击一下或者两下然后几秒之后才可以继续点击，这也是保护服务器的一种手段。
>
> **后端限流**：秒杀的时候肯定是涉及到后续的订单生成和支付等操作，但是都只是成功的幸运儿才会走到那一步，那一旦100个产品卖光了，return了一个false，前端直接秒杀结束，然后你后端也关闭后续无效请求的介入了。

#### 2.8库存预热

> 们要开始秒杀前你通过定时任务或者运维同学**提前把商品的库存加载到Redis中**去，让整个流程都在Redis里面去做，然后等秒杀结束了，再异步的去修改库存就好了。













